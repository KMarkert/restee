{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to the restee documentation restee is a package that aims to make plugging Earth Engine (EE) computations into downstream Python processing easier. The EE REST API allows user to interface with EE using REST API calls which allows for more flexibility in working with EE, however, without detailed knowleged of the API use it can be somewhat cryptic. restee aims to provide a user-friendly means to access computed server-side objects (like image data) from the earthengine-api API to a local Python enviroment (client-side). It should be noted that restee relies on fairly new and advanced EE features that may not be suitable for all users (see warning from the EE team ). If you are new to Earth Engine, please get started with the JavaScript guide . Getting Started This section is meant purely as a demonstration of what is possible, please see the Installation page for how to install package and setup the authentication then the Usage page for in depth information. In this case, we will compute a median NDVI composite for the Summer months over Central America using MODIS. Then we will request the data locally as a xarray.Dataset object so we can then use for local processing. import ee ee.Initialize() import restee as ree # get an authenticated session with GCP for REST API calls session = ree.EESession(\"<CLOUD-PROJECT>\",\"<PATH-TO-SECRET-KEY>\") # use ee to get a featurecollection for USA countries = ee.FeatureCollection(\"USDOS/LSIB_SIMPLE/2017\") camerica= countries.filter(ee.Filter.eq(\"wld_rgn\", \"Central America\")) # define the domain imagery will be requested for at ~1km resolution # in this case it is the computed Central America FeatureCollection domain = ree.Domain.from_ee_geometry(session,camerica,resolution=0.01) # define some image computations # here we calculate median NDVI for the summer months modis = ( ee.ImageCollection(\"MODIS/006/MOD09GA\") .filterDate(\"2020-06-01\",\"2020-09-01\") .map(lambda x: x.normalizedDifference([\"sur_refl_b02\",\"sur_refl_b01\"])) .median() .rename(\"NDVI\") ) # request the ee.Image pixels as a xarray dataset for the domain ndvi_ds = ree.img_to_xarray(session,domain,modis,no_data_value=0) # inspect the local xarray Dataset object ndvi_ds # output # <xarray.Dataset> # Dimensions: (lat: 1130, lon: 1509) # Coordinates: # * lon (lon) float64 -92.23 -92.22 -92.21 -92.2 ... -77.17 -77.16 -77.15 # * lat (lat) float64 18.48 18.47 18.46 18.45 ... 7.225 7.215 7.205 7.195 # Data variables: # NDVI (lat, lon) float32 nan nan nan nan nan nan ... nan nan nan nan nan From this point on the computed data is local to your system so you can do with it what you want. This allows the data to be plotted, persisted, or fed into another downstream process. For the sake of example, here we will plot the result. ndvi_ds.NDVI.plot(robust=True,cmap=\"viridis\") Again, this quick example was to highlight how a user may define an EE computation using the earthengine-api and request the data into a local data structure. One may use restee to get zonal statitics calculated for feature collections or even explore collection metadata, any format on EE can be requested locally. For more details, please see the Usage page . Get in touch Please report any bugs, ask questions, or suggest new features on GitHub . Contribute Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. License restee is available under the open source MIT License .","title":"Overview"},{"location":"index.html#welcome-to-the-restee-documentation","text":"restee is a package that aims to make plugging Earth Engine (EE) computations into downstream Python processing easier. The EE REST API allows user to interface with EE using REST API calls which allows for more flexibility in working with EE, however, without detailed knowleged of the API use it can be somewhat cryptic. restee aims to provide a user-friendly means to access computed server-side objects (like image data) from the earthengine-api API to a local Python enviroment (client-side). It should be noted that restee relies on fairly new and advanced EE features that may not be suitable for all users (see warning from the EE team ). If you are new to Earth Engine, please get started with the JavaScript guide .","title":"Welcome to the restee documentation"},{"location":"index.html#getting-started","text":"This section is meant purely as a demonstration of what is possible, please see the Installation page for how to install package and setup the authentication then the Usage page for in depth information. In this case, we will compute a median NDVI composite for the Summer months over Central America using MODIS. Then we will request the data locally as a xarray.Dataset object so we can then use for local processing. import ee ee.Initialize() import restee as ree # get an authenticated session with GCP for REST API calls session = ree.EESession(\"<CLOUD-PROJECT>\",\"<PATH-TO-SECRET-KEY>\") # use ee to get a featurecollection for USA countries = ee.FeatureCollection(\"USDOS/LSIB_SIMPLE/2017\") camerica= countries.filter(ee.Filter.eq(\"wld_rgn\", \"Central America\")) # define the domain imagery will be requested for at ~1km resolution # in this case it is the computed Central America FeatureCollection domain = ree.Domain.from_ee_geometry(session,camerica,resolution=0.01) # define some image computations # here we calculate median NDVI for the summer months modis = ( ee.ImageCollection(\"MODIS/006/MOD09GA\") .filterDate(\"2020-06-01\",\"2020-09-01\") .map(lambda x: x.normalizedDifference([\"sur_refl_b02\",\"sur_refl_b01\"])) .median() .rename(\"NDVI\") ) # request the ee.Image pixels as a xarray dataset for the domain ndvi_ds = ree.img_to_xarray(session,domain,modis,no_data_value=0) # inspect the local xarray Dataset object ndvi_ds # output # <xarray.Dataset> # Dimensions: (lat: 1130, lon: 1509) # Coordinates: # * lon (lon) float64 -92.23 -92.22 -92.21 -92.2 ... -77.17 -77.16 -77.15 # * lat (lat) float64 18.48 18.47 18.46 18.45 ... 7.225 7.215 7.205 7.195 # Data variables: # NDVI (lat, lon) float32 nan nan nan nan nan nan ... nan nan nan nan nan From this point on the computed data is local to your system so you can do with it what you want. This allows the data to be plotted, persisted, or fed into another downstream process. For the sake of example, here we will plot the result. ndvi_ds.NDVI.plot(robust=True,cmap=\"viridis\") Again, this quick example was to highlight how a user may define an EE computation using the earthengine-api and request the data into a local data structure. One may use restee to get zonal statitics calculated for feature collections or even explore collection metadata, any format on EE can be requested locally. For more details, please see the Usage page .","title":"Getting Started"},{"location":"index.html#get-in-touch","text":"Please report any bugs, ask questions, or suggest new features on GitHub .","title":"Get in touch"},{"location":"index.html#contribute","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contribute"},{"location":"index.html#license","text":"restee is available under the open source MIT License .","title":"License"},{"location":"core.html","text":"restee.core Domain Domain class to define spatial region for image requests Examples: Defines a psuedo-global domain at 1 degree resolution >>> coords = [ - 180 , - 60 , 180 , 85 ] >>> domain = restee . Domain ( coords , resolution = 1 ) >>> domain . shape ( 145 , 360 ) pixelgrid property readonly Property for json/dict represenstion of pixel grid info for requesting EE rasters. Used to define the spatial domain and shape of imagery for requests Returns: Type Description dict dictionary representation of pixel grid (https://developers.google.com/earth-engine/reference/rest/v1beta/PixelGrid) __init__ ( self , bbox , resolution = 0.25 , crs = 'EPSG:4326' ) special Initialize Domain class Parameters: Name Type Description Default bbox Iterable bounding box to create domain as [W,S,E,N] required resolution float resolution to make domain. default = 0.25 0.25 crs str string name of coordinate reference system of domain. resolution units must match the crs units. default = \"EPSG:4326\" 'EPSG:4326' Source code in restee/core.py def __init__ ( self , bbox : Iterable , resolution : float = 0.25 , crs : str = \"EPSG:4326\" ): \"\"\"Initialize Domain class args: bbox (Iterable): bounding box to create domain as [W,S,E,N] resolution (float): resolution to make domain. default = 0.25 crs (str): string name of coordinate reference system of domain. resolution units must match the crs units. default = \"EPSG:4326\" \"\"\" # set crs self . _crs = crs # set resolution info self . resolution = resolution # set the bounding box if np . any (( np . array ( bbox ) % self . resolution )) != 0 : self . bbox = Domain . _round_out ( bbox , self . resolution ) else : self . bbox = bbox minx , miny , maxx , maxy = self . bbox y_coords = np . arange ( miny + self . resolution , maxy + self . resolution , self . resolution )[:: - 1 ] x_coords = np . arange ( minx , maxx , self . resolution ) self . x_size = x_coords . size self . y_size = y_coords . size self . x_coords = x_coords self . y_coords = y_coords self . _construct_grid () self . _mask = np . ones ( self . shape ) return from_ee_geometry ( session , geom , resolution = 0.25 ) staticmethod Domain contructor function that takes a ee.Geometry, ee.Feature, or ee.FeatureCollection and returns a domain object with the geometry as a mask. Useful for using ee to process a region and use as domain for requsting imagery. Parameters: Name Type Description Default session EESession restee session autheticated to make requests required geom ee.Geometry|ee.Feature|ee.FeatureCollection ee object to create the domain from required resolution float resolution to make domain, must match units of vector crs. default = 0.25 0.25 Returns: Type Description restee.Domain domain object with mask from vector Source code in restee/core.py @staticmethod def from_ee_geometry ( session , geom , resolution : float = 0.25 ): \"\"\"Domain contructor function that takes a ee.Geometry, ee.Feature, or ee.FeatureCollection and returns a domain object with the geometry as a mask. Useful for using ee to process a region and use as domain for requsting imagery. args: session (EESession): restee session autheticated to make requests geom (ee.Geometry|ee.Feature|ee.FeatureCollection): ee object to create the domain from resolution (float): resolution to make domain, must match units of vector crs. default = 0.25 returns: restee.Domain: domain object with mask from vector \"\"\" if isinstance ( geom , ee . Geometry ): fc = ee . FeatureCollection ([ ee . Feature ( geom )]) elif isinstance ( geom , ee . Feature ): fc = ee . FeatureCollection ([ geom ]) else : fc = geom project = session . cloud_project url = f \"https://earthengine.googleapis.com/v1beta/projects/ { project } /table:computeFeatures\" serialized = ee . serializer . encode ( fc , for_cloud_api = True ) payload = dict ( expression = serialized ) response = session . send_request ( url , payload ) gdf = gpd . read_file ( StringIO ( response . content . decode ())) return Domain . from_geopandas ( gdf , resolution = resolution ) from_geopandas ( gdf , resolution = 0.25 ) staticmethod Domain constructor function that takes a GeoDataFrame and returns a domain object with the vector as a mask. Parameters: Name Type Description Default gdf geopandas.GeoDataFrame GeoDataFrame to create the domain from required resolution float resolution to make domain, must match units of vector crs. default = 0.25 0.25 Returns: Type Description restee.Domain domain object with mask from vector Source code in restee/core.py @staticmethod def from_geopandas ( gdf , resolution : float = 0.25 ): \"\"\"Domain constructor function that takes a GeoDataFrame and returns a domain object with the vector as a mask. args: gdf (geopandas.GeoDataFrame): GeoDataFrame to create the domain from resolution (float): resolution to make domain, must match units of vector crs. default = 0.25 returns: restee.Domain: domain object with mask from vector \"\"\" bbox = Domain . _round_out ( gdf . total_bounds , res = resolution ) crs = gdf . crs . srs d = Domain ( bbox , resolution , crs ) d . mask = features . geometry_mask ( gdf . geometry , d . shape , transform = d . transform , all_touched = True , invert = True ) return d from_rasterio ( ds , mask_val = None ) staticmethod Domain contructor function that takes a rasterio object and returns a domain with the same geotransform and crs Parameters: Name Type Description Default ds rasterio rasterio object to model domain from required Returns: Type Description restee.Domain domain object with same geotransform and crs as the input Source code in restee/core.py @staticmethod def from_rasterio ( ds , mask_val = None ): \"\"\"Domain contructor function that takes a rasterio object and returns a domain with the same geotransform and crs args: ds (rasterio): rasterio object to model domain from returns: restee.Domain: domain object with same geotransform and crs as the input \"\"\" resolution = np . mean ( ds . res ) crs = ds . crs . data [ \"init\" ] bbox = tuple ( ds . bounds ) d = Domain ( bbox , resolution , crs ) # TODO: add code to automatically mask no data values return d resample ( self , factor ) Function to resample domain shape and coordinates to a new resolution. Useful for requesting imagery over the same domain but at different spatial resolutions Parameters: Name Type Description Default factor float factor to scale the shape and coordinates. For example, if factor = 2, then the resolution will half and shape doubles. required Returns: Type Description restee.Domain domain object with new resolution/coordinates Source code in restee/core.py def resample ( self , factor : float ): \"\"\"Function to resample domain shape and coordinates to a new resolution. Useful for requesting imagery over the same domain but at different spatial resolutions args: factor (float): factor to scale the shape and coordinates. For example, if factor = 2, then the resolution will half and shape doubles. returns: restee.Domain: domain object with new resolution/coordinates \"\"\" new = copy . deepcopy ( self ) new . resolution = float ( new . resolution / factor ) # interpolate the x coordinates old_x = np . arange ( self . x_size ) * factor new_x = np . arange ( self . x_size * factor ) f_x = interpolate . interp1d ( old_x , self . x_coords , bounds_error = False , fill_value = \"extrapolate\" ) new . x_coords = f_x ( new_x ) old_x = np . arange ( self . y_size ) * factor new_x = np . arange ( self . y_size * factor ) f_y = interpolate . interp1d ( old_x , self . y_coords , bounds_error = False , fill_value = \"extrapolate\" ) new . y_coords = f_y ( new_x ) new . x_size = new . x_coords . size new . y_size = new . y_coords . size new . _construct_grid () interp_mask = ndimage . zoom ( self . mask , factor , order = 0 , mode = \"nearest\" ) new . mask = interp_mask . astype ( np . bool ) return new to_ee_bbox ( self ) Converts the domain bounding box to and ee.Geometry Returns: Type Description ee.Geometry bounding box of domain Source code in restee/core.py def to_ee_bbox ( self ): \"\"\"Converts the domain bounding box to and ee.Geometry returns: ee.Geometry: bounding box of domain \"\"\" return ee . Geometry . Rectangle ( self . bbox ) EESession EESession class that handles GCP/EE REST API info to make authenticated requests to Google Cloud. Users provides credentials that are used to create an authorized session to make HTTP requests __init__ ( self , project , key ) special Initialization function for the EESession class Parameters: Name Type Description Default project str Google Cloud project name with service account whitelisted to use Earth Engine required key str path to private key file for your whitelisted service account required Source code in restee/core.py def __init__ ( self , project : str , key : str ): \"\"\"Initialization function for the EESession class args: project (str): Google Cloud project name with service account whitelisted to use Earth Engine key (str): path to private key file for your whitelisted service account \"\"\" self . _PROJECT = project self . _SESSION = self . _get_session ( key ) send_request ( self , url , data ) Method to send authenticated requests to google cloud. This is wrapped with a backoff decorator that will try multiple requests if the initial ones fail. Parameters: Name Type Description Default url str EE REST API endpoint to send request. See https://developers.google.com/earth-engine/reference/rest for more info required data dict Dictionary object to send in the body of the Request. required Returns: Type Description response Reponse object with information on status and content Source code in restee/core.py @backoff . on_exception ( backoff . expo , requests . exceptions . RequestException , max_tries = 5 , max_time = 300 , giveup = _fatal_code , ) def send_request ( self , url , data ): \"\"\"Method to send authenticated requests to google cloud. This is wrapped with a backoff decorator that will try multiple requests if the initial ones fail. args: url (str): EE REST API endpoint to send request. See https://developers.google.com/earth-engine/reference/rest for more info data (dict): Dictionary object to send in the body of the Request. returns: response: Reponse object with information on status and content \"\"\" return self . session . post ( url = url , data = json . dumps ( data ))","title":"core module"},{"location":"core.html#restee.core","text":"","title":"core"},{"location":"core.html#restee.core.Domain","text":"Domain class to define spatial region for image requests Examples: Defines a psuedo-global domain at 1 degree resolution >>> coords = [ - 180 , - 60 , 180 , 85 ] >>> domain = restee . Domain ( coords , resolution = 1 ) >>> domain . shape ( 145 , 360 )","title":"Domain"},{"location":"core.html#restee.core.Domain.pixelgrid","text":"Property for json/dict represenstion of pixel grid info for requesting EE rasters. Used to define the spatial domain and shape of imagery for requests Returns: Type Description dict dictionary representation of pixel grid (https://developers.google.com/earth-engine/reference/rest/v1beta/PixelGrid)","title":"pixelgrid"},{"location":"core.html#restee.core.Domain.__init__","text":"Initialize Domain class Parameters: Name Type Description Default bbox Iterable bounding box to create domain as [W,S,E,N] required resolution float resolution to make domain. default = 0.25 0.25 crs str string name of coordinate reference system of domain. resolution units must match the crs units. default = \"EPSG:4326\" 'EPSG:4326' Source code in restee/core.py def __init__ ( self , bbox : Iterable , resolution : float = 0.25 , crs : str = \"EPSG:4326\" ): \"\"\"Initialize Domain class args: bbox (Iterable): bounding box to create domain as [W,S,E,N] resolution (float): resolution to make domain. default = 0.25 crs (str): string name of coordinate reference system of domain. resolution units must match the crs units. default = \"EPSG:4326\" \"\"\" # set crs self . _crs = crs # set resolution info self . resolution = resolution # set the bounding box if np . any (( np . array ( bbox ) % self . resolution )) != 0 : self . bbox = Domain . _round_out ( bbox , self . resolution ) else : self . bbox = bbox minx , miny , maxx , maxy = self . bbox y_coords = np . arange ( miny + self . resolution , maxy + self . resolution , self . resolution )[:: - 1 ] x_coords = np . arange ( minx , maxx , self . resolution ) self . x_size = x_coords . size self . y_size = y_coords . size self . x_coords = x_coords self . y_coords = y_coords self . _construct_grid () self . _mask = np . ones ( self . shape ) return","title":"__init__()"},{"location":"core.html#restee.core.Domain.from_ee_geometry","text":"Domain contructor function that takes a ee.Geometry, ee.Feature, or ee.FeatureCollection and returns a domain object with the geometry as a mask. Useful for using ee to process a region and use as domain for requsting imagery. Parameters: Name Type Description Default session EESession restee session autheticated to make requests required geom ee.Geometry|ee.Feature|ee.FeatureCollection ee object to create the domain from required resolution float resolution to make domain, must match units of vector crs. default = 0.25 0.25 Returns: Type Description restee.Domain domain object with mask from vector Source code in restee/core.py @staticmethod def from_ee_geometry ( session , geom , resolution : float = 0.25 ): \"\"\"Domain contructor function that takes a ee.Geometry, ee.Feature, or ee.FeatureCollection and returns a domain object with the geometry as a mask. Useful for using ee to process a region and use as domain for requsting imagery. args: session (EESession): restee session autheticated to make requests geom (ee.Geometry|ee.Feature|ee.FeatureCollection): ee object to create the domain from resolution (float): resolution to make domain, must match units of vector crs. default = 0.25 returns: restee.Domain: domain object with mask from vector \"\"\" if isinstance ( geom , ee . Geometry ): fc = ee . FeatureCollection ([ ee . Feature ( geom )]) elif isinstance ( geom , ee . Feature ): fc = ee . FeatureCollection ([ geom ]) else : fc = geom project = session . cloud_project url = f \"https://earthengine.googleapis.com/v1beta/projects/ { project } /table:computeFeatures\" serialized = ee . serializer . encode ( fc , for_cloud_api = True ) payload = dict ( expression = serialized ) response = session . send_request ( url , payload ) gdf = gpd . read_file ( StringIO ( response . content . decode ())) return Domain . from_geopandas ( gdf , resolution = resolution )","title":"from_ee_geometry()"},{"location":"core.html#restee.core.Domain.from_geopandas","text":"Domain constructor function that takes a GeoDataFrame and returns a domain object with the vector as a mask. Parameters: Name Type Description Default gdf geopandas.GeoDataFrame GeoDataFrame to create the domain from required resolution float resolution to make domain, must match units of vector crs. default = 0.25 0.25 Returns: Type Description restee.Domain domain object with mask from vector Source code in restee/core.py @staticmethod def from_geopandas ( gdf , resolution : float = 0.25 ): \"\"\"Domain constructor function that takes a GeoDataFrame and returns a domain object with the vector as a mask. args: gdf (geopandas.GeoDataFrame): GeoDataFrame to create the domain from resolution (float): resolution to make domain, must match units of vector crs. default = 0.25 returns: restee.Domain: domain object with mask from vector \"\"\" bbox = Domain . _round_out ( gdf . total_bounds , res = resolution ) crs = gdf . crs . srs d = Domain ( bbox , resolution , crs ) d . mask = features . geometry_mask ( gdf . geometry , d . shape , transform = d . transform , all_touched = True , invert = True ) return d","title":"from_geopandas()"},{"location":"core.html#restee.core.Domain.from_rasterio","text":"Domain contructor function that takes a rasterio object and returns a domain with the same geotransform and crs Parameters: Name Type Description Default ds rasterio rasterio object to model domain from required Returns: Type Description restee.Domain domain object with same geotransform and crs as the input Source code in restee/core.py @staticmethod def from_rasterio ( ds , mask_val = None ): \"\"\"Domain contructor function that takes a rasterio object and returns a domain with the same geotransform and crs args: ds (rasterio): rasterio object to model domain from returns: restee.Domain: domain object with same geotransform and crs as the input \"\"\" resolution = np . mean ( ds . res ) crs = ds . crs . data [ \"init\" ] bbox = tuple ( ds . bounds ) d = Domain ( bbox , resolution , crs ) # TODO: add code to automatically mask no data values return d","title":"from_rasterio()"},{"location":"core.html#restee.core.Domain.resample","text":"Function to resample domain shape and coordinates to a new resolution. Useful for requesting imagery over the same domain but at different spatial resolutions Parameters: Name Type Description Default factor float factor to scale the shape and coordinates. For example, if factor = 2, then the resolution will half and shape doubles. required Returns: Type Description restee.Domain domain object with new resolution/coordinates Source code in restee/core.py def resample ( self , factor : float ): \"\"\"Function to resample domain shape and coordinates to a new resolution. Useful for requesting imagery over the same domain but at different spatial resolutions args: factor (float): factor to scale the shape and coordinates. For example, if factor = 2, then the resolution will half and shape doubles. returns: restee.Domain: domain object with new resolution/coordinates \"\"\" new = copy . deepcopy ( self ) new . resolution = float ( new . resolution / factor ) # interpolate the x coordinates old_x = np . arange ( self . x_size ) * factor new_x = np . arange ( self . x_size * factor ) f_x = interpolate . interp1d ( old_x , self . x_coords , bounds_error = False , fill_value = \"extrapolate\" ) new . x_coords = f_x ( new_x ) old_x = np . arange ( self . y_size ) * factor new_x = np . arange ( self . y_size * factor ) f_y = interpolate . interp1d ( old_x , self . y_coords , bounds_error = False , fill_value = \"extrapolate\" ) new . y_coords = f_y ( new_x ) new . x_size = new . x_coords . size new . y_size = new . y_coords . size new . _construct_grid () interp_mask = ndimage . zoom ( self . mask , factor , order = 0 , mode = \"nearest\" ) new . mask = interp_mask . astype ( np . bool ) return new","title":"resample()"},{"location":"core.html#restee.core.Domain.to_ee_bbox","text":"Converts the domain bounding box to and ee.Geometry Returns: Type Description ee.Geometry bounding box of domain Source code in restee/core.py def to_ee_bbox ( self ): \"\"\"Converts the domain bounding box to and ee.Geometry returns: ee.Geometry: bounding box of domain \"\"\" return ee . Geometry . Rectangle ( self . bbox )","title":"to_ee_bbox()"},{"location":"core.html#restee.core.EESession","text":"EESession class that handles GCP/EE REST API info to make authenticated requests to Google Cloud. Users provides credentials that are used to create an authorized session to make HTTP requests","title":"EESession"},{"location":"core.html#restee.core.EESession.__init__","text":"Initialization function for the EESession class Parameters: Name Type Description Default project str Google Cloud project name with service account whitelisted to use Earth Engine required key str path to private key file for your whitelisted service account required Source code in restee/core.py def __init__ ( self , project : str , key : str ): \"\"\"Initialization function for the EESession class args: project (str): Google Cloud project name with service account whitelisted to use Earth Engine key (str): path to private key file for your whitelisted service account \"\"\" self . _PROJECT = project self . _SESSION = self . _get_session ( key )","title":"__init__()"},{"location":"core.html#restee.core.EESession.send_request","text":"Method to send authenticated requests to google cloud. This is wrapped with a backoff decorator that will try multiple requests if the initial ones fail. Parameters: Name Type Description Default url str EE REST API endpoint to send request. See https://developers.google.com/earth-engine/reference/rest for more info required data dict Dictionary object to send in the body of the Request. required Returns: Type Description response Reponse object with information on status and content Source code in restee/core.py @backoff . on_exception ( backoff . expo , requests . exceptions . RequestException , max_tries = 5 , max_time = 300 , giveup = _fatal_code , ) def send_request ( self , url , data ): \"\"\"Method to send authenticated requests to google cloud. This is wrapped with a backoff decorator that will try multiple requests if the initial ones fail. args: url (str): EE REST API endpoint to send request. See https://developers.google.com/earth-engine/reference/rest for more info data (dict): Dictionary object to send in the body of the Request. returns: response: Reponse object with information on status and content \"\"\" return self . session . post ( url = url , data = json . dumps ( data ))","title":"send_request()"},{"location":"images.html","text":"restee.images img_to_geotiff ( session , domain , image , outfile , bands = None ) Function to save requested ee.Image to a file in a GeoTIFF format Parameters: Name Type Description Default session EESession Earth Engine cloud session used to manage REST API requests required domain Domain Domain object defining the spatial region to request image required image Image computed ee.Image object to request required outfile str path to write requested data to required bands Iterable list or tuple or band names to request from image, if None then all bands will be requested. default = None None Examples: >>> img = ( ee . ImageCollection ( 'MODIS/006/MOD13Q1' ) . select ( \"NDVI\" ) . first () ) >>> states = ee . FeatureCollection ( 'TIGER/2018/States' ) >>> maine = states . filter ( ee . Filter . eq ( 'NAME' , 'Maine' )) >>> domain = restee . Domain . from_ee_geometry ( session , maine , 0.01 ) >>> ree . img_to_geotiff ( session , domain , img , \"maine_ndvi.tiff\" ) Source code in restee/images.py def img_to_geotiff ( session : EESession , domain : Domain , image : ee . Image , outfile : str , bands : Iterable = None , ): \"\"\"Function to save requested ee.Image to a file in a GeoTIFF format args: session (EESession): Earth Engine cloud session used to manage REST API requests domain (Domain): Domain object defining the spatial region to request image image (ee.Image): computed ee.Image object to request outfile (str): path to write requested data to bands (Iterable[str]): list or tuple or band names to request from image, if None then all bands will be requested. default = None example: >>> img = ( ee.ImageCollection('MODIS/006/MOD13Q1') .select(\"NDVI\") .first() ) >>> states = ee.FeatureCollection('TIGER/2018/States') >>> maine = states.filter(ee.Filter.eq('NAME', 'Maine')) >>> domain = restee.Domain.from_ee_geometry(session,maine,0.01) >>> ree.img_to_geotiff(session,domain,img,\"maine_ndvi.tiff\") \"\"\" outfile = Path ( outfile ) if bands is None : bands = get_value ( session , image . bandNames ()) pixels = _get_image ( session , domain , image , bands , dataformat = \"GEO_TIFF\" ) outfile . write_bytes ( pixels ) return img_to_ndarray ( session , domain , image , bands = None ) Function to request ee.Image as a numpy.ndarray Parameters: Name Type Description Default session EESession Earth Engine cloud session used to manage REST API requests required domain Domain Domain object defining the spatial region to request image required image Image computed ee.Image object to request required bands Iterable list or tuple or band names to request from image, if None then all bands will be requested. default = None None Returns: Type Description numpy.ndarray structured numpy array where each band from image is a named field Examples: >>> img = ( ee . ImageCollection ( 'MODIS/006/MOD13Q1' ) . select ( \"NDVI\" ) . first () ) >>> states = ee . FeatureCollection ( 'TIGER/2018/States' ) >>> maine = states . filter ( ee . Filter . eq ( 'NAME' , 'Maine' )) >>> domain = restee . Domain . from_ee_geometry ( session , maine , 0.01 ) >>> ndvi_arr = ree . img_to_ndarray ( session , domain , img ) Source code in restee/images.py def img_to_ndarray ( session : EESession , domain : Domain , image : ee . Image , bands : Iterable = None , ): \"\"\"Function to request ee.Image as a numpy.ndarray args: session (EESession): Earth Engine cloud session used to manage REST API requests domain (Domain): Domain object defining the spatial region to request image image (ee.Image): computed ee.Image object to request bands (Iterable[str]): list or tuple or band names to request from image, if None then all bands will be requested. default = None returns: numpy.ndarray: structured numpy array where each band from image is a named field example: >>> img = ( ee.ImageCollection('MODIS/006/MOD13Q1') .select(\"NDVI\") .first() ) >>> states = ee.FeatureCollection('TIGER/2018/States') >>> maine = states.filter(ee.Filter.eq('NAME', 'Maine')) >>> domain = restee.Domain.from_ee_geometry(session,maine,0.01) >>> ndvi_arr = ree.img_to_ndarray(session,domain,img) \"\"\" if bands is None : bands = get_value ( session , image . bandNames ()) pixels = _get_image ( session , domain , image , bands , dataformat = \"NPY\" ) return np . load ( BytesIO ( pixels )) img_to_xarray ( session , domain , image , bands = None , apply_mask = True , no_data_value = None ) Function to request ee.Image as a xarray Dataset. This function wraps img_to_ndarray. Parameters: Name Type Description Default session EESession Earth Engine cloud session used to manage REST API requests required domain Domain Domain object defining the spatial region to request image required image Image computed ee.Image object to request required bands Iterable list or tuple or band names to request from image, if None then all bands will be requested. default = None None apply_mask bool mask pixels based on domain mask. default = True True no_data_value float no data value to mask in returned dataset, typically 0. if None, then no data will be masked by value. default = None None Returns: Type Description xarray.Dataset dataset with geocoordinates and each band as a variable Examples: >>> img = ( ee . ImageCollection ( 'MODIS/006/MOD13Q1' ) . first () ) >>> states = ee . FeatureCollection ( 'TIGER/2018/States' ) >>> maine = states . filter ( ee . Filter . eq ( 'NAME' , 'Maine' )) >>> domain = restee . Domain . from_ee_geometry ( session , maine , 0.01 ) >>> ds_ndvi = ree . img_to_xarray ( session , domain , img , no_data_value = 0 ) Source code in restee/images.py def img_to_xarray ( session : EESession , domain : Domain , image : ee . Image , bands : Iterable = None , apply_mask : bool = True , no_data_value : float = None , ): \"\"\"Function to request ee.Image as a xarray Dataset. This function wraps img_to_ndarray. args: session (EESession): Earth Engine cloud session used to manage REST API requests domain (Domain): Domain object defining the spatial region to request image image (ee.Image): computed ee.Image object to request bands (Iterable[str]): list or tuple or band names to request from image, if None then all bands will be requested. default = None apply_mask (bool): mask pixels based on domain mask. default = True no_data_value (float): no data value to mask in returned dataset, typically 0. if None, then no data will be masked by value. default = None returns: xarray.Dataset: dataset with geocoordinates and each band as a variable example: >>> img = ( ee.ImageCollection('MODIS/006/MOD13Q1') .first() ) >>> states = ee.FeatureCollection('TIGER/2018/States') >>> maine = states.filter(ee.Filter.eq('NAME', 'Maine')) >>> domain = restee.Domain.from_ee_geometry(session,maine,0.01) >>> ds_ndvi = ree.img_to_xarray(session,domain,img,no_data_value=0) \"\"\" if bands is None : bands = get_value ( session , image . bandNames ()) pixels = img_to_ndarray ( session , domain , image , bands = bands ) bandnames = pixels . dtype . names if CRS . from_string ( domain . crs ) . is_geographic : x_name , y_name = \"lon\" , \"lat\" x_long , y_long = \"Longitude\" , \"Latitude\" x_units , y_units = \"degrees_east\" , \"degrees_north\" else : x_name , y_name = ( \"x\" , \"y\" , ) x_long , y_long = \"Eastings\" , \"Northings\" # assumes all non-geographic projections have m units... x_units , y_units = \"meters\" , \"meters\" # CF conventions are coordinates for center pixels # assign domain coordinates and shift to center coords = { x_name : ( [ x_name ], domain . x_coords + ( domain . resolution / 2 ), { \"units\" : x_units , \"long_name\" : x_long }, ), y_name : ( [ y_name ], domain . y_coords - ( domain . resolution / 2 ), { \"units\" : y_units , \"long_name\" : y_long }, ), } data_dict = { band : ([ y_name , x_name ], pixels [ band ]) for band in bandnames } ds = xr . Dataset ( data_dict , coords = coords ) if no_data_value is not None : ds = ds . where ( ds != no_data_value ) if apply_mask : ds = ds . where ( domain . mask == 1 ) return ds imgcollection_to_xarray ( session , domain , imagecollection , bands = None , max_workers = 5 , verbose = False , apply_mask = True , no_data_value = None ) Function to request ee.ImageCollection as a xarray Dataset. This function assumes the image collection is distinguished by time (i.e. 'system:time_start' property). Sends multiple concurrent requests to speed up data transfer. This function wraps img_to_ndarray. Parameters: Name Type Description Default session EESession Earth Engine cloud session used to manage REST API requests required domain Domain Domain object defining the spatial region to request image required imagecollection ImageCollection computed ee.ImageCollection object to request, images must have system:time_start property required bands Iterable list or tuple or band names to request from image, if None then all bands will be requested. default = None None max_workers int number of concurrent requests to send. default = 5, 5 verbose bool flag to determine if a request progress bar should be shown. default = False False apply_mask bool mask pixels based on domain mask. default = True True no_data_value float no data value to mask in returned dataset, typically 0. if None, then no data will be masked by value. default = None None Returns: Type Description xarray.Dataset dataset with multiple images along time dimesions, each band is a variable Examples: >>> ic = ( ee . ImageCollection ( 'MODIS/006/MOD13Q1' ) . limit ( 10 , \"system:time_start\" ) ) >>> states = ee . FeatureCollection ( 'TIGER/2018/States' ) >>> maine = states . filter ( ee . Filter . eq ( 'NAME' , 'Maine' )) >>> domain = restee . Domain . from_ee_geometry ( session , maine , 0.01 ) >>> ds_ndvi = ree . imgcollection_to_xarray ( session , domain , img , no_data_value = 0 , verbose = True ) Source code in restee/images.py def imgcollection_to_xarray ( session , domain : Domain , imagecollection : ee . ImageCollection , bands : Iterable = None , max_workers : int = 5 , verbose : bool = False , apply_mask : bool = True , no_data_value : float = None , ): \"\"\"Function to request ee.ImageCollection as a xarray Dataset. This function assumes the image collection is distinguished by time (i.e. 'system:time_start' property). Sends multiple concurrent requests to speed up data transfer. This function wraps img_to_ndarray. args: session (EESession): Earth Engine cloud session used to manage REST API requests domain (Domain): Domain object defining the spatial region to request image imagecollection (ee.ImageCollection): computed ee.ImageCollection object to request, images must have `system:time_start` property bands (Iterable[str]): list or tuple or band names to request from image, if None then all bands will be requested. default = None max_workers (int): number of concurrent requests to send. default = 5, verbose (bool): flag to determine if a request progress bar should be shown. default = False apply_mask (bool): mask pixels based on domain mask. default = True no_data_value (float): no data value to mask in returned dataset, typically 0. if None, then no data will be masked by value. default = None returns: xarray.Dataset: dataset with multiple images along time dimesions, each band is a variable example: >>> ic = ( ee.ImageCollection('MODIS/006/MOD13Q1') .limit(10,\"system:time_start\") ) >>> states = ee.FeatureCollection('TIGER/2018/States') >>> maine = states.filter(ee.Filter.eq('NAME', 'Maine')) >>> domain = restee.Domain.from_ee_geometry(session,maine,0.01) >>> ds_ndvi = ree.imgcollection_to_xarray(session,domain,img,no_data_value=0,verbose=True) \"\"\" #TODO: write functionality to allow the definition of ImageCollections by other properties than time dates = get_value ( session , imagecollection . aggregate_array ( \"system:time_start\" )) dates = pd . to_datetime ( list ( map ( lambda x : x / 1e-6 , dates ))) coll_id = get_value ( session , imagecollection . get ( \"system:id\" )) n_imgs = get_value ( session , imagecollection . size ()) if bands is None : bands = get_value ( session , ee . Image ( imagecollection . first ()) . bandNames ()) imgseq = range ( n_imgs ) imglist = imagecollection . toList ( n_imgs ) def request_func ( x ): return img_to_ndarray ( session , domain , ee . Image ( imglist . get ( x )), bands = bands ) if n_imgs < max_workers : gen = map ( request_func , imgseq ) if verbose : series = tuple ( tqdm ( gen , total = n_imgs , desc = f \" { coll_id } progress\" )) else : series = tuple ( gen ) else : with ThreadPoolExecutor ( max_workers ) as executor : gen = executor . map ( request_func , imgseq ) if verbose : series = tuple ( tqdm ( gen , total = n_imgs , desc = f \" { coll_id } progress\" )) else : series = tuple ( gen ) if CRS . from_string ( domain . crs ) . is_geographic : x_name , y_name = \"lon\" , \"lat\" x_long , y_long = \"Longitude\" , \"Latitude\" x_units , y_units = \"degrees_east\" , \"degrees_north\" else : x_name , y_name = ( \"x\" , \"y\" , ) x_long , y_long = \"Eastings\" , \"Northings\" # assumes all non-geographic projections have m units... x_units , y_units = \"meters\" , \"meters\" # CF conventions are coordinates for center pixels # assign domain coordinates and shift to center data_dict = { \"time\" : { \"dims\" : ( \"time\" ), \"data\" : dates }, x_name : { \"dims\" : ( x_name ), \"data\" : domain . x_coords + ( domain . resolution / 2 ), \"attrs\" : { \"long_name\" : x_long , \"units\" : x_units }, }, y_name : { \"dims\" : ( y_name ), \"data\" : domain . y_coords - ( domain . resolution / 2 ), \"attrs\" : { \"long_name\" : y_long , \"units\" : y_units }, }, } bandnames = series [ 0 ] . dtype . names series_shp = ( n_imgs , domain . y_size , domain . x_size ) for i in range ( n_imgs ): for band in bandnames : if i == 0 : data_dict [ band ] = { \"dims\" : ( \"time\" , y_name , x_name ), \"data\" : np . zeros ( series_shp ), } data_dict [ band ][ \"data\" ][ i , :, :] = series [ i ][ band ][:, :] ds = xr . Dataset . from_dict ( data_dict ) if no_data_value is not None : ds = ds . where ( ds != no_data_value ) if apply_mask : ds = ds . where ( domain . mask == 1 ) return ds","title":"images module"},{"location":"images.html#restee.images","text":"","title":"images"},{"location":"images.html#restee.images.img_to_geotiff","text":"Function to save requested ee.Image to a file in a GeoTIFF format Parameters: Name Type Description Default session EESession Earth Engine cloud session used to manage REST API requests required domain Domain Domain object defining the spatial region to request image required image Image computed ee.Image object to request required outfile str path to write requested data to required bands Iterable list or tuple or band names to request from image, if None then all bands will be requested. default = None None Examples: >>> img = ( ee . ImageCollection ( 'MODIS/006/MOD13Q1' ) . select ( \"NDVI\" ) . first () ) >>> states = ee . FeatureCollection ( 'TIGER/2018/States' ) >>> maine = states . filter ( ee . Filter . eq ( 'NAME' , 'Maine' )) >>> domain = restee . Domain . from_ee_geometry ( session , maine , 0.01 ) >>> ree . img_to_geotiff ( session , domain , img , \"maine_ndvi.tiff\" ) Source code in restee/images.py def img_to_geotiff ( session : EESession , domain : Domain , image : ee . Image , outfile : str , bands : Iterable = None , ): \"\"\"Function to save requested ee.Image to a file in a GeoTIFF format args: session (EESession): Earth Engine cloud session used to manage REST API requests domain (Domain): Domain object defining the spatial region to request image image (ee.Image): computed ee.Image object to request outfile (str): path to write requested data to bands (Iterable[str]): list or tuple or band names to request from image, if None then all bands will be requested. default = None example: >>> img = ( ee.ImageCollection('MODIS/006/MOD13Q1') .select(\"NDVI\") .first() ) >>> states = ee.FeatureCollection('TIGER/2018/States') >>> maine = states.filter(ee.Filter.eq('NAME', 'Maine')) >>> domain = restee.Domain.from_ee_geometry(session,maine,0.01) >>> ree.img_to_geotiff(session,domain,img,\"maine_ndvi.tiff\") \"\"\" outfile = Path ( outfile ) if bands is None : bands = get_value ( session , image . bandNames ()) pixels = _get_image ( session , domain , image , bands , dataformat = \"GEO_TIFF\" ) outfile . write_bytes ( pixels ) return","title":"img_to_geotiff()"},{"location":"images.html#restee.images.img_to_ndarray","text":"Function to request ee.Image as a numpy.ndarray Parameters: Name Type Description Default session EESession Earth Engine cloud session used to manage REST API requests required domain Domain Domain object defining the spatial region to request image required image Image computed ee.Image object to request required bands Iterable list or tuple or band names to request from image, if None then all bands will be requested. default = None None Returns: Type Description numpy.ndarray structured numpy array where each band from image is a named field Examples: >>> img = ( ee . ImageCollection ( 'MODIS/006/MOD13Q1' ) . select ( \"NDVI\" ) . first () ) >>> states = ee . FeatureCollection ( 'TIGER/2018/States' ) >>> maine = states . filter ( ee . Filter . eq ( 'NAME' , 'Maine' )) >>> domain = restee . Domain . from_ee_geometry ( session , maine , 0.01 ) >>> ndvi_arr = ree . img_to_ndarray ( session , domain , img ) Source code in restee/images.py def img_to_ndarray ( session : EESession , domain : Domain , image : ee . Image , bands : Iterable = None , ): \"\"\"Function to request ee.Image as a numpy.ndarray args: session (EESession): Earth Engine cloud session used to manage REST API requests domain (Domain): Domain object defining the spatial region to request image image (ee.Image): computed ee.Image object to request bands (Iterable[str]): list or tuple or band names to request from image, if None then all bands will be requested. default = None returns: numpy.ndarray: structured numpy array where each band from image is a named field example: >>> img = ( ee.ImageCollection('MODIS/006/MOD13Q1') .select(\"NDVI\") .first() ) >>> states = ee.FeatureCollection('TIGER/2018/States') >>> maine = states.filter(ee.Filter.eq('NAME', 'Maine')) >>> domain = restee.Domain.from_ee_geometry(session,maine,0.01) >>> ndvi_arr = ree.img_to_ndarray(session,domain,img) \"\"\" if bands is None : bands = get_value ( session , image . bandNames ()) pixels = _get_image ( session , domain , image , bands , dataformat = \"NPY\" ) return np . load ( BytesIO ( pixels ))","title":"img_to_ndarray()"},{"location":"images.html#restee.images.img_to_xarray","text":"Function to request ee.Image as a xarray Dataset. This function wraps img_to_ndarray. Parameters: Name Type Description Default session EESession Earth Engine cloud session used to manage REST API requests required domain Domain Domain object defining the spatial region to request image required image Image computed ee.Image object to request required bands Iterable list or tuple or band names to request from image, if None then all bands will be requested. default = None None apply_mask bool mask pixels based on domain mask. default = True True no_data_value float no data value to mask in returned dataset, typically 0. if None, then no data will be masked by value. default = None None Returns: Type Description xarray.Dataset dataset with geocoordinates and each band as a variable Examples: >>> img = ( ee . ImageCollection ( 'MODIS/006/MOD13Q1' ) . first () ) >>> states = ee . FeatureCollection ( 'TIGER/2018/States' ) >>> maine = states . filter ( ee . Filter . eq ( 'NAME' , 'Maine' )) >>> domain = restee . Domain . from_ee_geometry ( session , maine , 0.01 ) >>> ds_ndvi = ree . img_to_xarray ( session , domain , img , no_data_value = 0 ) Source code in restee/images.py def img_to_xarray ( session : EESession , domain : Domain , image : ee . Image , bands : Iterable = None , apply_mask : bool = True , no_data_value : float = None , ): \"\"\"Function to request ee.Image as a xarray Dataset. This function wraps img_to_ndarray. args: session (EESession): Earth Engine cloud session used to manage REST API requests domain (Domain): Domain object defining the spatial region to request image image (ee.Image): computed ee.Image object to request bands (Iterable[str]): list or tuple or band names to request from image, if None then all bands will be requested. default = None apply_mask (bool): mask pixels based on domain mask. default = True no_data_value (float): no data value to mask in returned dataset, typically 0. if None, then no data will be masked by value. default = None returns: xarray.Dataset: dataset with geocoordinates and each band as a variable example: >>> img = ( ee.ImageCollection('MODIS/006/MOD13Q1') .first() ) >>> states = ee.FeatureCollection('TIGER/2018/States') >>> maine = states.filter(ee.Filter.eq('NAME', 'Maine')) >>> domain = restee.Domain.from_ee_geometry(session,maine,0.01) >>> ds_ndvi = ree.img_to_xarray(session,domain,img,no_data_value=0) \"\"\" if bands is None : bands = get_value ( session , image . bandNames ()) pixels = img_to_ndarray ( session , domain , image , bands = bands ) bandnames = pixels . dtype . names if CRS . from_string ( domain . crs ) . is_geographic : x_name , y_name = \"lon\" , \"lat\" x_long , y_long = \"Longitude\" , \"Latitude\" x_units , y_units = \"degrees_east\" , \"degrees_north\" else : x_name , y_name = ( \"x\" , \"y\" , ) x_long , y_long = \"Eastings\" , \"Northings\" # assumes all non-geographic projections have m units... x_units , y_units = \"meters\" , \"meters\" # CF conventions are coordinates for center pixels # assign domain coordinates and shift to center coords = { x_name : ( [ x_name ], domain . x_coords + ( domain . resolution / 2 ), { \"units\" : x_units , \"long_name\" : x_long }, ), y_name : ( [ y_name ], domain . y_coords - ( domain . resolution / 2 ), { \"units\" : y_units , \"long_name\" : y_long }, ), } data_dict = { band : ([ y_name , x_name ], pixels [ band ]) for band in bandnames } ds = xr . Dataset ( data_dict , coords = coords ) if no_data_value is not None : ds = ds . where ( ds != no_data_value ) if apply_mask : ds = ds . where ( domain . mask == 1 ) return ds","title":"img_to_xarray()"},{"location":"images.html#restee.images.imgcollection_to_xarray","text":"Function to request ee.ImageCollection as a xarray Dataset. This function assumes the image collection is distinguished by time (i.e. 'system:time_start' property). Sends multiple concurrent requests to speed up data transfer. This function wraps img_to_ndarray. Parameters: Name Type Description Default session EESession Earth Engine cloud session used to manage REST API requests required domain Domain Domain object defining the spatial region to request image required imagecollection ImageCollection computed ee.ImageCollection object to request, images must have system:time_start property required bands Iterable list or tuple or band names to request from image, if None then all bands will be requested. default = None None max_workers int number of concurrent requests to send. default = 5, 5 verbose bool flag to determine if a request progress bar should be shown. default = False False apply_mask bool mask pixels based on domain mask. default = True True no_data_value float no data value to mask in returned dataset, typically 0. if None, then no data will be masked by value. default = None None Returns: Type Description xarray.Dataset dataset with multiple images along time dimesions, each band is a variable Examples: >>> ic = ( ee . ImageCollection ( 'MODIS/006/MOD13Q1' ) . limit ( 10 , \"system:time_start\" ) ) >>> states = ee . FeatureCollection ( 'TIGER/2018/States' ) >>> maine = states . filter ( ee . Filter . eq ( 'NAME' , 'Maine' )) >>> domain = restee . Domain . from_ee_geometry ( session , maine , 0.01 ) >>> ds_ndvi = ree . imgcollection_to_xarray ( session , domain , img , no_data_value = 0 , verbose = True ) Source code in restee/images.py def imgcollection_to_xarray ( session , domain : Domain , imagecollection : ee . ImageCollection , bands : Iterable = None , max_workers : int = 5 , verbose : bool = False , apply_mask : bool = True , no_data_value : float = None , ): \"\"\"Function to request ee.ImageCollection as a xarray Dataset. This function assumes the image collection is distinguished by time (i.e. 'system:time_start' property). Sends multiple concurrent requests to speed up data transfer. This function wraps img_to_ndarray. args: session (EESession): Earth Engine cloud session used to manage REST API requests domain (Domain): Domain object defining the spatial region to request image imagecollection (ee.ImageCollection): computed ee.ImageCollection object to request, images must have `system:time_start` property bands (Iterable[str]): list or tuple or band names to request from image, if None then all bands will be requested. default = None max_workers (int): number of concurrent requests to send. default = 5, verbose (bool): flag to determine if a request progress bar should be shown. default = False apply_mask (bool): mask pixels based on domain mask. default = True no_data_value (float): no data value to mask in returned dataset, typically 0. if None, then no data will be masked by value. default = None returns: xarray.Dataset: dataset with multiple images along time dimesions, each band is a variable example: >>> ic = ( ee.ImageCollection('MODIS/006/MOD13Q1') .limit(10,\"system:time_start\") ) >>> states = ee.FeatureCollection('TIGER/2018/States') >>> maine = states.filter(ee.Filter.eq('NAME', 'Maine')) >>> domain = restee.Domain.from_ee_geometry(session,maine,0.01) >>> ds_ndvi = ree.imgcollection_to_xarray(session,domain,img,no_data_value=0,verbose=True) \"\"\" #TODO: write functionality to allow the definition of ImageCollections by other properties than time dates = get_value ( session , imagecollection . aggregate_array ( \"system:time_start\" )) dates = pd . to_datetime ( list ( map ( lambda x : x / 1e-6 , dates ))) coll_id = get_value ( session , imagecollection . get ( \"system:id\" )) n_imgs = get_value ( session , imagecollection . size ()) if bands is None : bands = get_value ( session , ee . Image ( imagecollection . first ()) . bandNames ()) imgseq = range ( n_imgs ) imglist = imagecollection . toList ( n_imgs ) def request_func ( x ): return img_to_ndarray ( session , domain , ee . Image ( imglist . get ( x )), bands = bands ) if n_imgs < max_workers : gen = map ( request_func , imgseq ) if verbose : series = tuple ( tqdm ( gen , total = n_imgs , desc = f \" { coll_id } progress\" )) else : series = tuple ( gen ) else : with ThreadPoolExecutor ( max_workers ) as executor : gen = executor . map ( request_func , imgseq ) if verbose : series = tuple ( tqdm ( gen , total = n_imgs , desc = f \" { coll_id } progress\" )) else : series = tuple ( gen ) if CRS . from_string ( domain . crs ) . is_geographic : x_name , y_name = \"lon\" , \"lat\" x_long , y_long = \"Longitude\" , \"Latitude\" x_units , y_units = \"degrees_east\" , \"degrees_north\" else : x_name , y_name = ( \"x\" , \"y\" , ) x_long , y_long = \"Eastings\" , \"Northings\" # assumes all non-geographic projections have m units... x_units , y_units = \"meters\" , \"meters\" # CF conventions are coordinates for center pixels # assign domain coordinates and shift to center data_dict = { \"time\" : { \"dims\" : ( \"time\" ), \"data\" : dates }, x_name : { \"dims\" : ( x_name ), \"data\" : domain . x_coords + ( domain . resolution / 2 ), \"attrs\" : { \"long_name\" : x_long , \"units\" : x_units }, }, y_name : { \"dims\" : ( y_name ), \"data\" : domain . y_coords - ( domain . resolution / 2 ), \"attrs\" : { \"long_name\" : y_long , \"units\" : y_units }, }, } bandnames = series [ 0 ] . dtype . names series_shp = ( n_imgs , domain . y_size , domain . x_size ) for i in range ( n_imgs ): for band in bandnames : if i == 0 : data_dict [ band ] = { \"dims\" : ( \"time\" , y_name , x_name ), \"data\" : np . zeros ( series_shp ), } data_dict [ band ][ \"data\" ][ i , :, :] = series [ i ][ band ][:, :] ds = xr . Dataset . from_dict ( data_dict ) if no_data_value is not None : ds = ds . where ( ds != no_data_value ) if apply_mask : ds = ds . where ( domain . mask == 1 ) return ds","title":"imgcollection_to_xarray()"},{"location":"installation.html","text":"restee Installation This pages walks you through setting up the restee package as well as points users to the documentation for setting up a GCP project for use with the EE REST API. Before beginning Before proceeding with the package installation, please see the instructions to setup a service account for access to the REST API. Instructions for setting up your service account can be found here Once you have a Google Cloud Project and whitelisted service accout for the cloud project, you will need to create a private key so that your system can securely communicate with the Google Cloud. Instructions for creating a private key can be found here Lastly, test the setup by following the instructions here Installing the package restee relies heavily on the geospatial Python ecosystem to manage different geospatial data formats and execute geospatial processes. It is recommended to use conda to handle the package dependencies and create a virtual environment to work with restee . To do this run the following command: conda create -n restee -c conda-forge -y \\ python>=3.6 \\ numpy \\ scipy \\ pandas \\ xarray \\ rasterio \\ geopandas \\ pyproj \\ requests \\ backoff \\ earthengine-api \\ tqdm Once all of the dependencies are installed, the restee package can be installed using pip : pip install restee","title":"Installation"},{"location":"installation.html#restee-installation","text":"This pages walks you through setting up the restee package as well as points users to the documentation for setting up a GCP project for use with the EE REST API.","title":"restee Installation"},{"location":"installation.html#before-beginning","text":"Before proceeding with the package installation, please see the instructions to setup a service account for access to the REST API. Instructions for setting up your service account can be found here Once you have a Google Cloud Project and whitelisted service accout for the cloud project, you will need to create a private key so that your system can securely communicate with the Google Cloud. Instructions for creating a private key can be found here Lastly, test the setup by following the instructions here","title":"Before beginning"},{"location":"installation.html#installing-the-package","text":"restee relies heavily on the geospatial Python ecosystem to manage different geospatial data formats and execute geospatial processes. It is recommended to use conda to handle the package dependencies and create a virtual environment to work with restee . To do this run the following command: conda create -n restee -c conda-forge -y \\ python>=3.6 \\ numpy \\ scipy \\ pandas \\ xarray \\ rasterio \\ geopandas \\ pyproj \\ requests \\ backoff \\ earthengine-api \\ tqdm Once all of the dependencies are installed, the restee package can be installed using pip : pip install restee","title":"Installing the package"},{"location":"tables.html","text":"restee.tables features_to_df ( session , features ) Fuction to request ee.Feature or ee.FeatureCollection without coordinates as a pandas DataFrame Parameters: Name Type Description Default session EESession restee session autheticated to make requests required features FeatureCollection ee.Feature or ee.FeatureCollections to request as a DataFrame required Returns: Type Description pandas.DataFrame ee.FeatureCollection as DataFrame Examples: >>> ndvi = ( ee . ImageCollection ( 'MODIS/006/MOD13Q1' ) . select ( \"NDVI\" ) . first () ) >>> temp = ee . ImageCollection ( 'OREGONSTATE/PRISM/AN81m' ) . filter ( ee . Filter . date ( '2018-07-01' , '2018-07-31' )); >>> states = ee . FeatureCollection ( 'TIGER/2018/States' ) >>> features = image . reduceRegions ( collection = maine , reducer = ee . Reducer . mean () . setOutputs ([ \"NDVI\" ]), scale = image . projection () . nominalScale () ) >>> gdf = restee . features_to_geopandas ( session , features ) Source code in restee/tables.py def features_to_df ( session : EESession , features : ee . FeatureCollection ): \"\"\"Fuction to request ee.Feature or ee.FeatureCollection without coordinates as a pandas DataFrame args: session (EESession): restee session autheticated to make requests features (ee.Feature | ee.FeatureCollection): ee.Feature or ee.FeatureCollections to request as a DataFrame returns: pandas.DataFrame: ee.FeatureCollection as DataFrame example: >>> ndvi = ( ee.ImageCollection('MODIS/006/MOD13Q1') .select(\"NDVI\") .first() ) >>> temp = ee.ImageCollection('OREGONSTATE/PRISM/AN81m') .filter(ee.Filter.date('2018-07-01', '2018-07-31')); >>> states = ee.FeatureCollection('TIGER/2018/States') >>> features = image.reduceRegions( collection=maine, reducer=ee.Reducer.mean().setOutputs([\"NDVI\"]), scale=image.projection().nominalScale() ) >>> gdf = restee.features_to_geopandas(session,features) \"\"\" if isinstance ( features , ee . Feature ): features = ee . FeatureCollection ([ features ]) table = _get_table ( session , features ) return pd . read_file ( StringIO ( table . decode ())) features_to_file ( session , features , outfile , driver = 'GeoJSON' ) Wrapper fuction to save requested ee.Feature or ee.FeatureCollection in a vector format Parameters: Name Type Description Default session EESession restee session autheticated to make requests required features FeatureCollection ee.Feature or ee.FeatureCollections save as file required outfile str path to save features required driver str valid vector driver name to save file, see import fiona; fiona.supported_drivers for full list of supported drivers . default = \"GeoJSON\" 'GeoJSON' Examples: >>> img = ( ee . ImageCollection ( 'MODIS/006/MOD13Q1' ) . select ( \"NDVI\" ) . first () ) >>> states = ee . FeatureCollection ( 'TIGER/2018/States' ) >>> features = image . reduceRegions ( collection = maine , reducer = ee . Reducer . mean () . setOutputs ([ \"NDVI\" ]), scale = image . projection () . nominalScale () ) >>> restee . features_to_file ( session , features , \"state_ndvi.geojson\" ) Source code in restee/tables.py def features_to_file ( session : EESession , features : ee . FeatureCollection , outfile : str , driver : str = \"GeoJSON\" ): \"\"\"Wrapper fuction to save requested ee.Feature or ee.FeatureCollection in a vector format args: session (EESession): restee session autheticated to make requests features (ee.Feature | ee.FeatureCollection): ee.Feature or ee.FeatureCollections save as file outfile (str): path to save features driver (str): valid vector driver name to save file, see `import fiona; fiona.supported_drivers` for full list of supported drivers . default = \"GeoJSON\" example: >>> img = ( ee.ImageCollection('MODIS/006/MOD13Q1') .select(\"NDVI\") .first() ) >>> states = ee.FeatureCollection('TIGER/2018/States') >>> features = image.reduceRegions( collection=maine, reducer=ee.Reducer.mean().setOutputs([\"NDVI\"]), scale=image.projection().nominalScale() ) >>> restee.features_to_file(session,features,\"state_ndvi.geojson\") \"\"\" gdf = features_to_geopandas ( session , features ) gdf . to_file ( outfile , driver = driver ) return features_to_geodf ( session , features ) Fuction to request ee.Feature or ee.FeatureCollection as a geopandas GeoDataFrame Parameters: Name Type Description Default session EESession restee session autheticated to make requests required features FeatureCollection ee.Feature or ee.FeatureCollections to request as a GeoDataFrame required Returns: Type Description geopandas.GeoDataFrame ee.FeatureCollection as GeoDataFrame Examples: >>> img = ( ee . ImageCollection ( 'MODIS/006/MOD13Q1' ) . select ( \"NDVI\" ) . first () ) >>> states = ee . FeatureCollection ( 'TIGER/2018/States' ) >>> features = image . reduceRegions ( collection = maine , reducer = ee . Reducer . mean () . setOutputs ([ \"NDVI\" ]), scale = image . projection () . nominalScale () ) >>> gdf = restee . features_to_geopandas ( session , features ) Source code in restee/tables.py def features_to_geodf ( session : EESession , features : ee . FeatureCollection ): \"\"\"Fuction to request ee.Feature or ee.FeatureCollection as a geopandas GeoDataFrame args: session (EESession): restee session autheticated to make requests features (ee.Feature | ee.FeatureCollection): ee.Feature or ee.FeatureCollections to request as a GeoDataFrame returns: geopandas.GeoDataFrame: ee.FeatureCollection as GeoDataFrame example: >>> img = ( ee.ImageCollection('MODIS/006/MOD13Q1') .select(\"NDVI\") .first() ) >>> states = ee.FeatureCollection('TIGER/2018/States') >>> features = image.reduceRegions( collection=maine, reducer=ee.Reducer.mean().setOutputs([\"NDVI\"]), scale=image.projection().nominalScale() ) >>> gdf = restee.features_to_geopandas(session,features) \"\"\" if isinstance ( features , ee . Feature ): features = ee . FeatureCollection ([ features ]) table = _get_table ( session , features ) return gpd . read_file ( StringIO ( table . decode ()))","title":"tables module"},{"location":"tables.html#restee.tables","text":"","title":"tables"},{"location":"tables.html#restee.tables.features_to_df","text":"Fuction to request ee.Feature or ee.FeatureCollection without coordinates as a pandas DataFrame Parameters: Name Type Description Default session EESession restee session autheticated to make requests required features FeatureCollection ee.Feature or ee.FeatureCollections to request as a DataFrame required Returns: Type Description pandas.DataFrame ee.FeatureCollection as DataFrame Examples: >>> ndvi = ( ee . ImageCollection ( 'MODIS/006/MOD13Q1' ) . select ( \"NDVI\" ) . first () ) >>> temp = ee . ImageCollection ( 'OREGONSTATE/PRISM/AN81m' ) . filter ( ee . Filter . date ( '2018-07-01' , '2018-07-31' )); >>> states = ee . FeatureCollection ( 'TIGER/2018/States' ) >>> features = image . reduceRegions ( collection = maine , reducer = ee . Reducer . mean () . setOutputs ([ \"NDVI\" ]), scale = image . projection () . nominalScale () ) >>> gdf = restee . features_to_geopandas ( session , features ) Source code in restee/tables.py def features_to_df ( session : EESession , features : ee . FeatureCollection ): \"\"\"Fuction to request ee.Feature or ee.FeatureCollection without coordinates as a pandas DataFrame args: session (EESession): restee session autheticated to make requests features (ee.Feature | ee.FeatureCollection): ee.Feature or ee.FeatureCollections to request as a DataFrame returns: pandas.DataFrame: ee.FeatureCollection as DataFrame example: >>> ndvi = ( ee.ImageCollection('MODIS/006/MOD13Q1') .select(\"NDVI\") .first() ) >>> temp = ee.ImageCollection('OREGONSTATE/PRISM/AN81m') .filter(ee.Filter.date('2018-07-01', '2018-07-31')); >>> states = ee.FeatureCollection('TIGER/2018/States') >>> features = image.reduceRegions( collection=maine, reducer=ee.Reducer.mean().setOutputs([\"NDVI\"]), scale=image.projection().nominalScale() ) >>> gdf = restee.features_to_geopandas(session,features) \"\"\" if isinstance ( features , ee . Feature ): features = ee . FeatureCollection ([ features ]) table = _get_table ( session , features ) return pd . read_file ( StringIO ( table . decode ()))","title":"features_to_df()"},{"location":"tables.html#restee.tables.features_to_file","text":"Wrapper fuction to save requested ee.Feature or ee.FeatureCollection in a vector format Parameters: Name Type Description Default session EESession restee session autheticated to make requests required features FeatureCollection ee.Feature or ee.FeatureCollections save as file required outfile str path to save features required driver str valid vector driver name to save file, see import fiona; fiona.supported_drivers for full list of supported drivers . default = \"GeoJSON\" 'GeoJSON' Examples: >>> img = ( ee . ImageCollection ( 'MODIS/006/MOD13Q1' ) . select ( \"NDVI\" ) . first () ) >>> states = ee . FeatureCollection ( 'TIGER/2018/States' ) >>> features = image . reduceRegions ( collection = maine , reducer = ee . Reducer . mean () . setOutputs ([ \"NDVI\" ]), scale = image . projection () . nominalScale () ) >>> restee . features_to_file ( session , features , \"state_ndvi.geojson\" ) Source code in restee/tables.py def features_to_file ( session : EESession , features : ee . FeatureCollection , outfile : str , driver : str = \"GeoJSON\" ): \"\"\"Wrapper fuction to save requested ee.Feature or ee.FeatureCollection in a vector format args: session (EESession): restee session autheticated to make requests features (ee.Feature | ee.FeatureCollection): ee.Feature or ee.FeatureCollections save as file outfile (str): path to save features driver (str): valid vector driver name to save file, see `import fiona; fiona.supported_drivers` for full list of supported drivers . default = \"GeoJSON\" example: >>> img = ( ee.ImageCollection('MODIS/006/MOD13Q1') .select(\"NDVI\") .first() ) >>> states = ee.FeatureCollection('TIGER/2018/States') >>> features = image.reduceRegions( collection=maine, reducer=ee.Reducer.mean().setOutputs([\"NDVI\"]), scale=image.projection().nominalScale() ) >>> restee.features_to_file(session,features,\"state_ndvi.geojson\") \"\"\" gdf = features_to_geopandas ( session , features ) gdf . to_file ( outfile , driver = driver ) return","title":"features_to_file()"},{"location":"tables.html#restee.tables.features_to_geodf","text":"Fuction to request ee.Feature or ee.FeatureCollection as a geopandas GeoDataFrame Parameters: Name Type Description Default session EESession restee session autheticated to make requests required features FeatureCollection ee.Feature or ee.FeatureCollections to request as a GeoDataFrame required Returns: Type Description geopandas.GeoDataFrame ee.FeatureCollection as GeoDataFrame Examples: >>> img = ( ee . ImageCollection ( 'MODIS/006/MOD13Q1' ) . select ( \"NDVI\" ) . first () ) >>> states = ee . FeatureCollection ( 'TIGER/2018/States' ) >>> features = image . reduceRegions ( collection = maine , reducer = ee . Reducer . mean () . setOutputs ([ \"NDVI\" ]), scale = image . projection () . nominalScale () ) >>> gdf = restee . features_to_geopandas ( session , features ) Source code in restee/tables.py def features_to_geodf ( session : EESession , features : ee . FeatureCollection ): \"\"\"Fuction to request ee.Feature or ee.FeatureCollection as a geopandas GeoDataFrame args: session (EESession): restee session autheticated to make requests features (ee.Feature | ee.FeatureCollection): ee.Feature or ee.FeatureCollections to request as a GeoDataFrame returns: geopandas.GeoDataFrame: ee.FeatureCollection as GeoDataFrame example: >>> img = ( ee.ImageCollection('MODIS/006/MOD13Q1') .select(\"NDVI\") .first() ) >>> states = ee.FeatureCollection('TIGER/2018/States') >>> features = image.reduceRegions( collection=maine, reducer=ee.Reducer.mean().setOutputs([\"NDVI\"]), scale=image.projection().nominalScale() ) >>> gdf = restee.features_to_geopandas(session,features) \"\"\" if isinstance ( features , ee . Feature ): features = ee . FeatureCollection ([ features ]) table = _get_table ( session , features ) return gpd . read_file ( StringIO ( table . decode ()))","title":"features_to_geodf()"},{"location":"usage.html","text":"Using restee The page serves as more in depth examples of using restee to get data from Earth Engine results. Before walking through these examples, please make sure you have gone throught the Installation page and installed everything correctly. To begin, we will need to import the ee and restee packages. Next, we need to authenticate Earth Engine and create a authenticated cloud session so we can request the data from the server to our local system. import ee ee.Initialize() import restee as ree # get and authenticated cloud session for requesting data session = ree.EESession(\"<CLOUD-PROJECT>\",\"<PATH-TO-SECRET-KEY>\") Now we are ready to crunch some data! Requesting Images Earth Engines core capabilities come from massive geospatial raster processing. It makes working with and processing imagery much easier but often times, one would like to use the results with some other process. restee allows for users to request processed imagery to local data structures such as states = ee.FeatureCollection('TIGER/2018/States') maine = states.filter(ee.Filter.eq('NAME', 'Maine')) # get a domain for the state of Maine at ~500m resolution domain = ree.Domain.from_ee_geometry(session, maine, resolution=0.005) imshow(domain.mask) Now that we have a domain we can use that to control where on the globe we request imagery. Here we simply grab the first image in the MOD13Q1 NDVI collection and request the data for Maine. # get an ee.Image object img = ( ee.ImageCollection('MODIS/006/MOD13Q1') .select(\"NDVI\") .first() ) # request the image as an np.ndarray using the domain ndvi_arr = ree.img_to_ndarray(session,domain,img) # inspect the data structure of ndvi_arr ndvi_arr # array([[( 3905,), ( 3880,), ( 2823,), ..., ( 2522,), ( 1714,), ( 1714,)], # [( 3605,), ( 3447,), ( 3447,), ..., ( 3845,), ( 2324,), ( 2324,)], # [( 3399,), ( 3315,), ( 3315,), ..., ( 4584,), ( 2238,), ( 2238,)], # ..., # [( 5711,), ( 5611,), ( 4905,), ..., (-3000,), (-3000,), (-3000,)], # [( 4845,), ( 4791,), ( 4606,), ..., (-3000,), (-3000,), (-3000,)], # [( 5101,), ( 4443,), ( 4610,), ..., (-3000,), (-3000,), (-3000,)]], # dtype=[('NDVI', '<i2')]) The resulting numpy array is the raw data from EE for the region and projected in the coordiates defined by domain . The restee.img_to_ndarray only returns a structured array of pixel values. To request data while retaining the geographic information, please see the restee.img_to_xarray function. We can not only request individual images but also an ImageCollection over a region. To do this, the ImageCollection needs to have a system:time_start property (this is important when doing some computations as EE drops metadata properties). We will use the Maine example again, however, this time request the first ten images in the collection as a xarray.Dataset which allows us to manage the time dimension # grab the first 10 NDVI images from a MODIS collection ic = ( ee.ImageCollection('MODIS/006/MOD13Q1') .limit(10,\"system:time_start\") .select(\"NDVI\") ) ds_ndvi = ree.imgcollection_to_xarray(session,domain,ic,no_data_value=0,verbose=True) # plot the results ds_ndvi.where(ds_ndvi.NDVI>=0).NDVI.plot(col='time',col_wrap=5,robust=True,cmap='Greens') This function is handy as it allows for geographic as well as time information to be retained. It is planned to allow users to define an ImageCollection by other properties than system:time_start , however, since ImageCollections are most often time based this functionality should serve most purposes. Requesting Tables Imagery is not the only thing that Earth Engine can process. There are many vector based workflows that are useful on Earth Engine such as sampling values from an image or calculating zonal statistics. To access computed a computed feature or feature collection, restee has methods to request the data in a local table structure. In this example, we will calculate the average NDVI from a MODIS image for the countries in Southeast Asia: countries = ee.FeatureCollection(\"USDOS/LSIB_SIMPLE/2017\") seasia = countries.filter(ee.Filter.eq(\"wld_rgn\", \"SE Asia\")) computation = img.reduceRegions( collection=seasia, reducer=ee.Reducer.mean().setOutputs([\"NDVI\"]), scale=1000 ) gdf = ree.features_to_geodf(session,computation) gdf.plot(column=\"NDVI\",cmap=\"Greens\") Not all computed ee.Feature or ee.FeatureCollections have geometry information, to support the lack of geometry data, restee also has a function restee.features_to_df to request the data as a pandas.DataFrame . Requesting Values Not all information from Earth Engine is a spatial computation. Sometimes calculating statistics or reading metadata from the image/collections is needed. We can request essentially any ee.ComputedObject to a local Python data type and continue using on our local system. Here is a quick example of getting a list of dates from an image collection: ic = ( ee.ImageCollection('MODIS/006/MOD13Q1') .limit(10,\"system:time_start\") .select(\"NDVI\") ) # compute the string format of the image dates ee_dates = ( ic.aggregate_array(\"system:time_start\") .map(lambda x: ee.Date(x).format(\"YYYY-MM-dd HH:mm:ss\")) ) # get this list of date strings dates = ree.get_value(session, ee_dates) dates # output # ['2000-02-18 00:00:00', # '2000-03-05 00:00:00', # '2000-03-21 00:00:00', # '2000-04-06 00:00:00', # '2000-04-22 00:00:00', # '2000-05-08 00:00:00', # '2000-05-24 00:00:00', # '2000-06-09 00:00:00', # '2000-06-25 00:00:00', # '2000-07-11 00:00:00'] The restee.get_value function takes essentially any ee.ComputedObject (such as ee.List, ee.Array, ee.Dictionary, ee.String)and will convert it to the Python equivalent for use locally. Caveauts There is a limit to how much data/computations you can request. Typically this manifests itself in 500 error. Please note that this is an Earth Image limit and has little to do with restee . Please refer to the Quotas and Limits section of the REST API documentation to learn more.","title":"Usage"},{"location":"usage.html#using-restee","text":"The page serves as more in depth examples of using restee to get data from Earth Engine results. Before walking through these examples, please make sure you have gone throught the Installation page and installed everything correctly. To begin, we will need to import the ee and restee packages. Next, we need to authenticate Earth Engine and create a authenticated cloud session so we can request the data from the server to our local system. import ee ee.Initialize() import restee as ree # get and authenticated cloud session for requesting data session = ree.EESession(\"<CLOUD-PROJECT>\",\"<PATH-TO-SECRET-KEY>\") Now we are ready to crunch some data!","title":"Using restee"},{"location":"usage.html#requesting-images","text":"Earth Engines core capabilities come from massive geospatial raster processing. It makes working with and processing imagery much easier but often times, one would like to use the results with some other process. restee allows for users to request processed imagery to local data structures such as states = ee.FeatureCollection('TIGER/2018/States') maine = states.filter(ee.Filter.eq('NAME', 'Maine')) # get a domain for the state of Maine at ~500m resolution domain = ree.Domain.from_ee_geometry(session, maine, resolution=0.005) imshow(domain.mask) Now that we have a domain we can use that to control where on the globe we request imagery. Here we simply grab the first image in the MOD13Q1 NDVI collection and request the data for Maine. # get an ee.Image object img = ( ee.ImageCollection('MODIS/006/MOD13Q1') .select(\"NDVI\") .first() ) # request the image as an np.ndarray using the domain ndvi_arr = ree.img_to_ndarray(session,domain,img) # inspect the data structure of ndvi_arr ndvi_arr # array([[( 3905,), ( 3880,), ( 2823,), ..., ( 2522,), ( 1714,), ( 1714,)], # [( 3605,), ( 3447,), ( 3447,), ..., ( 3845,), ( 2324,), ( 2324,)], # [( 3399,), ( 3315,), ( 3315,), ..., ( 4584,), ( 2238,), ( 2238,)], # ..., # [( 5711,), ( 5611,), ( 4905,), ..., (-3000,), (-3000,), (-3000,)], # [( 4845,), ( 4791,), ( 4606,), ..., (-3000,), (-3000,), (-3000,)], # [( 5101,), ( 4443,), ( 4610,), ..., (-3000,), (-3000,), (-3000,)]], # dtype=[('NDVI', '<i2')]) The resulting numpy array is the raw data from EE for the region and projected in the coordiates defined by domain . The restee.img_to_ndarray only returns a structured array of pixel values. To request data while retaining the geographic information, please see the restee.img_to_xarray function. We can not only request individual images but also an ImageCollection over a region. To do this, the ImageCollection needs to have a system:time_start property (this is important when doing some computations as EE drops metadata properties). We will use the Maine example again, however, this time request the first ten images in the collection as a xarray.Dataset which allows us to manage the time dimension # grab the first 10 NDVI images from a MODIS collection ic = ( ee.ImageCollection('MODIS/006/MOD13Q1') .limit(10,\"system:time_start\") .select(\"NDVI\") ) ds_ndvi = ree.imgcollection_to_xarray(session,domain,ic,no_data_value=0,verbose=True) # plot the results ds_ndvi.where(ds_ndvi.NDVI>=0).NDVI.plot(col='time',col_wrap=5,robust=True,cmap='Greens') This function is handy as it allows for geographic as well as time information to be retained. It is planned to allow users to define an ImageCollection by other properties than system:time_start , however, since ImageCollections are most often time based this functionality should serve most purposes.","title":"Requesting Images"},{"location":"usage.html#requesting-tables","text":"Imagery is not the only thing that Earth Engine can process. There are many vector based workflows that are useful on Earth Engine such as sampling values from an image or calculating zonal statistics. To access computed a computed feature or feature collection, restee has methods to request the data in a local table structure. In this example, we will calculate the average NDVI from a MODIS image for the countries in Southeast Asia: countries = ee.FeatureCollection(\"USDOS/LSIB_SIMPLE/2017\") seasia = countries.filter(ee.Filter.eq(\"wld_rgn\", \"SE Asia\")) computation = img.reduceRegions( collection=seasia, reducer=ee.Reducer.mean().setOutputs([\"NDVI\"]), scale=1000 ) gdf = ree.features_to_geodf(session,computation) gdf.plot(column=\"NDVI\",cmap=\"Greens\") Not all computed ee.Feature or ee.FeatureCollections have geometry information, to support the lack of geometry data, restee also has a function restee.features_to_df to request the data as a pandas.DataFrame .","title":"Requesting Tables"},{"location":"usage.html#requesting-values","text":"Not all information from Earth Engine is a spatial computation. Sometimes calculating statistics or reading metadata from the image/collections is needed. We can request essentially any ee.ComputedObject to a local Python data type and continue using on our local system. Here is a quick example of getting a list of dates from an image collection: ic = ( ee.ImageCollection('MODIS/006/MOD13Q1') .limit(10,\"system:time_start\") .select(\"NDVI\") ) # compute the string format of the image dates ee_dates = ( ic.aggregate_array(\"system:time_start\") .map(lambda x: ee.Date(x).format(\"YYYY-MM-dd HH:mm:ss\")) ) # get this list of date strings dates = ree.get_value(session, ee_dates) dates # output # ['2000-02-18 00:00:00', # '2000-03-05 00:00:00', # '2000-03-21 00:00:00', # '2000-04-06 00:00:00', # '2000-04-22 00:00:00', # '2000-05-08 00:00:00', # '2000-05-24 00:00:00', # '2000-06-09 00:00:00', # '2000-06-25 00:00:00', # '2000-07-11 00:00:00'] The restee.get_value function takes essentially any ee.ComputedObject (such as ee.List, ee.Array, ee.Dictionary, ee.String)and will convert it to the Python equivalent for use locally.","title":"Requesting Values"},{"location":"usage.html#caveauts","text":"There is a limit to how much data/computations you can request. Typically this manifests itself in 500 error. Please note that this is an Earth Image limit and has little to do with restee . Please refer to the Quotas and Limits section of the REST API documentation to learn more.","title":"Caveauts"},{"location":"values.html","text":"restee.values get_value ( session , value ) General EE REST API wrapper to request any ee.ComputedObject value Parameters: Name Type Description Default session EESession restee session autheticated to make requests required value Any any ee.ComputedObject to request the value for required Returns: Type Description Any Python evaluated equivalent of ee object Examples: >>> img = ee . Image ( \"NASA/NASADEM_HGT/001\" ) >>> ee_bnames = img . bandNames () >>> band_names = restee . get_value ( session , ee_bnames ) >>> print ( band_names ) [ 'elevation' , 'num' , 'swb' ] Source code in restee/values.py def get_value ( session : EESession , value ): \"\"\"General EE REST API wrapper to request any ee.ComputedObject value args: session (EESession): restee session autheticated to make requests value (Any): any ee.ComputedObject to request the value for returns: Any: Python evaluated equivalent of ee object example: >>> img = ee.Image(\"NASA/NASADEM_HGT/001\") >>> ee_bnames = img.bandNames() >>> band_names = restee.get_value(session, ee_bnames) >>> print(band_names) ['elevation', 'num', 'swb'] \"\"\" project = session . cloud_project url = f 'https://earthengine.googleapis.com/v1beta/projects/ { project } /value:compute' serialized = ee . serializer . encode ( value , for_cloud_api = True ) payload = dict ( expression = serialized ) response = session . send_request ( url , payload ) if response . status_code != 200 : raise requests . exceptions . RequestException ( f \"received the following bad status code: { response . status_code } \\n Server message: { response . json ()[ 'error' ][ 'message' ] } \" ) return response . json ()[ 'result' ]","title":"values module"},{"location":"values.html#restee.values","text":"","title":"values"},{"location":"values.html#restee.values.get_value","text":"General EE REST API wrapper to request any ee.ComputedObject value Parameters: Name Type Description Default session EESession restee session autheticated to make requests required value Any any ee.ComputedObject to request the value for required Returns: Type Description Any Python evaluated equivalent of ee object Examples: >>> img = ee . Image ( \"NASA/NASADEM_HGT/001\" ) >>> ee_bnames = img . bandNames () >>> band_names = restee . get_value ( session , ee_bnames ) >>> print ( band_names ) [ 'elevation' , 'num' , 'swb' ] Source code in restee/values.py def get_value ( session : EESession , value ): \"\"\"General EE REST API wrapper to request any ee.ComputedObject value args: session (EESession): restee session autheticated to make requests value (Any): any ee.ComputedObject to request the value for returns: Any: Python evaluated equivalent of ee object example: >>> img = ee.Image(\"NASA/NASADEM_HGT/001\") >>> ee_bnames = img.bandNames() >>> band_names = restee.get_value(session, ee_bnames) >>> print(band_names) ['elevation', 'num', 'swb'] \"\"\" project = session . cloud_project url = f 'https://earthengine.googleapis.com/v1beta/projects/ { project } /value:compute' serialized = ee . serializer . encode ( value , for_cloud_api = True ) payload = dict ( expression = serialized ) response = session . send_request ( url , payload ) if response . status_code != 200 : raise requests . exceptions . RequestException ( f \"received the following bad status code: { response . status_code } \\n Server message: { response . json ()[ 'error' ][ 'message' ] } \" ) return response . json ()[ 'result' ]","title":"get_value()"}]}